圣诞节糖果
链接：https://ac.nowcoder.com/acm/problem/14675
来源：牛客网

题目描述 
圣诞节临近，彩虹岛的黑心商人𝑐𝑡𝑟的糖果店又开始热闹了起来，热心的𝑠𝑙𝑝来到𝑐𝑡𝑟的店里面帮忙包装糖果。
店里面共有𝑛堆糖果，其中第𝑖堆有𝑎𝑖颗糖果，𝑐𝑡𝑟让𝑠𝑙𝑝从中选择两堆糖果，这两堆糖果中每𝑝 颗包装在一起，
如果最后还有剩余就归𝑠𝑙𝑝所有了，若两堆不足𝑝个则全部归𝑠𝑙𝑝所有。
作为糖果狂热爱好者，𝑠𝑙𝑝当然是想拿走尽量多的糖果，因此他想知道自己最多能够拿走多少糖果。

输入描述:
输入第一行为一个整数𝑇(1 ≤ 𝑇 ≤ 10)，表示一共有𝑇组测试数据。
对于每组测试数据：
第一行有两个整数𝑛(2 ≤ 𝑛 ≤ 105), 𝑝(1 ≤ 𝑝 ≤ 109)，分别表示糖果堆数和包装后每包糖果的数量。
第二行有𝑛个整数，其中第𝑖个数𝑎𝑖(1 ≤ 𝑎𝑖 ≤ 109)表示第𝑖堆糖果的数量。
输出描述:
对于每组测试数据，输出一个整数𝑥表示𝑠𝑙𝑝能拿走的最多的糖果数目。
示例1
输入
复制
2
4 5
1 4 2 3
4 15
12 19 13 20
输出
复制
4
10
说明
对于第一组样例，𝑠𝑙𝑝选择第一堆和第四堆是最佳选择，会剩余4颗糖果。
对于第二组样例，𝑠𝑙𝑝选择第一堆和第三堆是最佳选择，会剩余10颗糖果。



思路：
先输入数据，然后对输入的每袋糖果进行对p取余，得到每袋剩余的糖果数量，然后进行排序，
先定义maxn，将最后两袋之和对p取余后的值赋给maxn;然后进入循环，直到左右边界相等才结束，再进入一个循环，从左边界开始，每一项元素与右边界之和若大于等于p，则右边界减一，
直到左右边界剩余糖果数之和小于p，然后比较maxn和左右边界之和的大小，将大的赋值给maxn,然后再比较下一个元素，最后输出maxn。



代码：
//圣诞节糖果
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n,p;
        long long maxn;
        cin>>n>>p;
        long long a[n+5];
        for(int i=1;i<=n;i++)//输入
        {
            cin>>a[i];
            a[i]%=p;//每袋糖果装袋后剩余的
        }
        sort(a+1,a+n+1);//升序排序，即剩余糖果色从小到大排列
        maxn=(a[n-1]+a[n])%p;//最后两袋剩余的糖果装袋后剩余的，若不足p，则值不变
        int l=1,r=n;//左右边界
        while(l<r)//从左边界开始，每一个元素进行比较
        {
            while(a[l]+a[r]>=p)//若剩余的糖果大于p，则右边界减一
                r--;
            if(l<r)
            {
                maxn=max(maxn,a[l]+a[r]);//比较最后两袋剩余糖果和左右边界剩余糖果数目
                l++;
            }
        }
        cout<<maxn<<endl;//输出
    }
    return 0;
}
        
        
                  


