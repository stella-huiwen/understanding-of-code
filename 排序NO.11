消息列表
链接：https://ac.nowcoder.com/acm/problem/15716
来源：牛客网

题目描述 
当你的好友给你发来一条消息，你的消息列表上就会置顶显示该好友的名字以及该好友发给你的消息总数，换句话说，你的消息列表里的好友是按跟你发消息的时间进行排序的，给你发消息的时间离当前时间越近的好友将排到越前面。当然，你可能会手动置顶一些好友，那么其他的好友给你发消息时，他们的名字就只能在你手动置顶好友的后面再置顶了。如果消息被你查看或者忽略，又或者你把好友消息删除了，消息总数将重置为0。

根据用户的需求，有以下几个功能，需要你来实现：
（1）recv：收到一条好友消息，对于手动置顶好友的消息，将在“手动置顶好友列表”里置顶；对于其他好友的消息，将在“手动置顶好友列表”之下的消息列表里置顶，同时都需要显示该好友的消息总数。
（2）view：查看好友消息，将使该好友消息数变为0。
（3）up：手动置顶好友。
（4）down：取消手动置顶。
（5）delete：删除好友消息，这个操作将使该好友从消息列表中删除，同时取消对该好友的手动置顶（如果存在的话）。

假设初始消息列表为空，经过了一系列好友消息的操作之后，最终的消息列表将是怎么样的呢？
输入描述:
第一行输入一个整数T（表示样例个数）
接下来T组样例。
每组样例
第一行输入一个整数M，表示操作数（1≤M≤1000000）；
接下来M行，
每行输入一个操作，由一个操作类型和一个好友id构成，之间以空格分开，操作类型如上面5个英文单词表示，
例如：“recv 123456”表示接收到id为123456的好友的一条消息，“delete 123456”表示在消息列表中删除 id 为123456的好友的消息记录。
为了简化问题，一开始消息列表为空并假设好友名字id由六位数字“唯一”标识（000000≤id≤999999），
题目保证输入数据的一致性。
输出描述:
每组样例，
输出最后的消息列表，自顶向下，每行输出一个：“好友id 消息数”。
每组样例后空一行。
示例1
输入
复制
1
13
recv 000001
recv 000002
up 000002
view 000001
recv 000002
recv 000004
up 000004
up 000001
recv 000004
recv 000003
view 000001
view 000004
down 000002
输出
复制
000004 0
000001 0
000003 1
000002 2



代码：
//消息列表
#include<bits/stdc++.h>
using namespace std;
struct body
{
    int id;//好友名字
    int news;//消息数
    int pri;//接收消息顺序数
    bool zd;//置顶
};
bool cmp(body a,body b)//排序
{
    if(a.zd!=b.zd)//若一个有置顶，一个无置顶，则有置顶的优先
        return a.zd>b.zd;
    else
        return a.pri>b.pri;//若都有置顶或者都无置顶，则按照消息顺序
}
int main()
{
    int t,m;
    char a[1005];
    struct body man[1000000];
    cin>>t;
    while(t--)
    {
        cin>>m;
        int ans=1,idx;
        memset(man,0,sizeof(man));//初始化为零
        for(int i=0;i<m;i++)
        {
            scanf("%s%d",a,&idx);
            man[idx].id=idx;
            if(a[0]=='r')//操作为recv，表示收到消息，且顺序数+1
            {
                man[idx].news++;
                man[idx].pri=ans++;
            }
            else if(a[0]=='v')//view表示查看消息，使得news数变为0
                man[idx].news=0;
            else if(a[0]=='u')//up表示置顶
                man[idx].zd=1;
            else if(a[1]=='o')//down表示取消置顶
                man[idx].zd=0;
            else if(a[2]=='l')//delete表示删除好友信息，即消息数，顺序数，置顶都归零
            {
                man[idx].news=0;
                man[idx].pri=0;
                man[idx].zd=0;
            }
        }
        sort(man,man+1000000,cmp);//排序
        for(int i=0;i<1000000;i++)//输出
        {
            if(man[i].pri!=0)
                printf("%06d %d\n",man[i].id,man[i].news);//注意：id由6位数字组成
        }
        printf("\n");
    }
    return 0;
}
