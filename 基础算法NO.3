同余定理
2个不同的整数a、b，被一个整数m相除时，得到相同的余数，那么我就可以称a、b同
 因为a、b同余所以当他们相减时，余数就抵消掉了，剩下的那部分就是能被m整除的。
 
证明：
   q1=a/m+r,q2=b/m+r
   a=mq1+r,b=mq2+r
   a-b=m(q1-q2)
->q1-q2=(a-b)/m 
即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，记作：a≡b(mod m)


两个数除以m得到相同的余数，求m的最大的数值
#include<bits/stdc++.h>
using namespace std;
int main()
{
int a,b;
scanf("%d %d",&a,&b);
int ans=max(a,b)-min(a,b);
for(int i=min(a,b);i>=1;i--)
{
if(ans%i==0)
{
  printf("%d",i);
  return 0;
  }
  }
  }


性质：
反身性：a≡a (mod m)

对称性： 若a≡b(mod m)，则b≡a(mod m)

传递性： 若a≡b(mod m)，b≡c(mod m)，则a≡c(mod m)

同余式相加：若a≡b(mod m)，c≡d(mod m)，则a ± c≡b ± d(mod m)

同余式相乘：若a≡b(mod m)，c≡d(mod m)，则ac≡bd(mod m)

线性运算：如果a≡b(mod m)，c≡d(mod m)，那么a ± c≡b ± d(mod m)，且a * c≡b * d(mod m)

除法：若ac ≡ bc (mod m) c≠0 则 a ≡ b (mod m/gcd(c,m)) 其中gcd(c,m)表示c,m的最大公约数。特殊地 ,gcd(c,m)=1 则a ≡ b (mod m)

幂运算：如果a ≡ b (mod m)，那么a^n ≡ b^n (mod m)

若a ≡ b (mod m)，n|m,则 a ≡ b (mod n)

若a ≡ b (mod mi) (i=1,2…n) 则 a ≡ b (mod [m1,m2,…mn]) 其中[m1,m2,…mn]表示m1,m2,…mn的最小公倍数
