康托逆展开
已知一个排列大小为第68，但是循环是从0开始计数，所以68要减1，即67
67 / 4! = 2 余 19 
19 / 3! = 3 余 1  1 / 2! = 0 余 1 
1 / 1! = 1 余0 
 0 / 0! = 0 余0
通过辗转相除，我们可以求得a[5] = 2, a[4] = 3, a[3] = 0, a[2] = 1, a[1] = 0 
那么，序列的第一个值便可求得，在五个元素内，有2个元素比它小，所以是3 
第二个元素：除去3后，还有元素1，2，4，5，后面共有3个元素比它小，所以是5 
第三个元素：除去3和5后，还有元素1，2，4，后面共有0个元素比它小，所以是1 
第四个元素：除去1，3，5，还有元素2，4，后面有1个元素比它小，所以是4 
第五个元素：除去1，3，4，5，还有元素2，后面有0个元素比它小，所以是2
这样，我们就将康托展开值逆展开了，序列为3，5，1，4，2，即35142


代码：
#include <iostream>
#include<algorithm>
#include<cstdio>
#include<string>
using namespace std;
int main()
{
    int fact[]={1,1,2,6,24,120,720,5040,40320,362880};//阶乘
    int a,j,n,t,ans[10]={0};//a:第a大的数，n：数字个数
    int s[100000];//s为展开数
    scanf("%d%d",&a,&n);
    a--;
    for(int i=0;i<n;i++)
    {
        t=a/fact[n-1-i];
        for( j=1;j<=n;j++)
        {
            if(!ans[j])
            {
                if(t==0)
                break;
                --t;
            }
        }
        s[i]=j;
        ans[j]=1;
        a=a%fact[n-1-i];
    }
    for(int i=0;i<n;i++)
    printf("%d",s[i]);
    return 0;
}

