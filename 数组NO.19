扫雷游戏地雷数计算
总时间限制: 1000ms 内存限制: 65536kB
描述
扫雷游戏是一款十分经典的单机小游戏。它的精髓在于，通过已翻开格子所提示的周围格地雷数，来判断未翻开格子里是否是地雷。

现在给出n行m列的雷区中的地雷分布，要求计算出每个非地雷格的周围格地雷数。

注：每个格子周围格有八个：上、下、左、右、左上、右上、左下、右下。

输入
第一行包含两个整数n和m，分别表示雷区的行数和列数。1 <= n <= 100, 1 <= m <= 100。
接下来n行，每行m个字符，‘*’表示相应格子中是地雷，‘？’表示相应格子中无地雷。字符之间无任何分隔符。
输出
n行，每行m个字符，描述整个雷区。若相应格中是地雷，则用‘*’表示，否则用相应的周围格地雷数表示。字符之间无任何分隔符。
样例输入
3 3
*??
???
?*?
样例输出
*10
221
1*1



代码：
//扫雷游戏地雷数计算
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,m,count=0;
    cin>>n>>m;
    char a[n+5][m+5];
    int b[n+5][m+5];
    for(int i=0;i<n;i++)//输入
        for(int j=0;j<m;j++)
            cin>>a[i][j];
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            if(a[i][j]=='*')//进行判断且直接输出，缩短运行时间
            cout<<a[i][j];//当a为*时，直接输出数组a，避免转换数组b
            if(a[i][j]=='?')
            {
                if(a[i][j-1]=='*')
                count++;
                if(a[i][j+1]=='*')
                count++;
                if(a[i-1][j]=='*')
                count++;
                if(a[i+1][j]=='*')
                count++;
                if(a[i-1][j-1]=='*')
                count++;
                if(a[i-1][j+1]=='*')
                count++;
                if(a[i+1][j-1]=='*')
                count++;
                if(a[i+1][j+1]=='*')
                count++;
                b[i][j]=count;
                cout<<b[i][j];
            }
            count=0;
        }
        printf("\n");
    }
    return 0;
}
