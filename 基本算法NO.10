牛牛的朋友
链接：https://ac.nowcoder.com/acm/problem/21545
来源：牛客网

题目描述 
牛牛有一群牛友，每只小牛都站在坐标轴上的某个位置，这群牛友很听牛牛的话，每当牛牛做个手势，每只小牛都会移动恰好X个单位的距离，要么向左，要么向右

现在告诉你每只小牛在移动前的位置，求移动之后最左边的牛与最右边的牛的最小距离
输入描述:
第一行输入一个整数n (1 ≤ n  ≤ 50)，表示牛的数量
第二行输入n个数pi (-1e8 ≤ pi ≤ 1e8)，表示每只牛的位置 
第三行输入一个整数X (0 ≤ X ≤ 1e8)
输出描述:
输出一个整数
示例1
输入
复制
3
-3 0 1
3
输出
复制
3
说明

示例2
输入
复制
3
4 7 -7
5
输出
复制
4
说明

示例3
输入
复制
2
-100000000 100000000
100000000
输出
复制
0
示例4
输入
复制
9
3 7 4 6 -10 7 10 9 -5
7
输出
复制
7
示例5
输入
复制
4
-4 0 4 0
4
输出
复制
4
示例6
输入
复制
1
7
0
输出
复制
0
备注:
子任务1：n <= 10
子任务2: n <= 20
子任务3: n <= 50



思路：
要求移动后距离最短，要比较两种情况，
1.左右两边都进行相同的移动，即距离不变时是最短的

2.左右两边进行不相同的移动，此时，要求最短距离，则左端点应向右移动，而中间的每一项点向左移动，循环比较二者的大小，取小的重新赋值给左端点
同时，右端点应向左移动，而中间的每一项点向右移动，循环比较二者的大小，取大的重新赋值给右端点。然后比较左右两端点的最初距离和循环重新赋值后的左右端点的距离的大小，
最后取较小的输出

代码：
//牛牛的朋友
#include<bits/stdc++.h>
using namespace std;
int a[55];
int main()
{
     int n,sum,l,r,x;
     cin>>n;//输入
     for(int i=1;i<=n;i++)
     cin>>a[i];
     cin>>x;
     sort(a+1,a+n+1);//升序排序
     sum=a[n]-a[1];//最初的左右两端距离
     for(int i=1;i<=n;i++)
     {
         l=min(a[1]+x,a[i+1]-x);//左端
         r=max(a[i]+x,a[n]-x);//右端
         sum=min(sum,r-l);//最小距离
     }
     cout<<sum<<endl;//输出
     return 0;
}
























