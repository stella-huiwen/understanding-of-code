最大子矩阵和
描述
已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。

比如，如下4 * 4的矩阵

0 -2 -7 0
9 2 -6 2
-4 1 -4 1
-1 8 0 -2

的最大子矩阵是

9 2
-4 1
-1 8

这个子矩阵的大小是15。
输入
输入是一个N * N的矩阵。输入的第一行给出N (0 < N <= 100)。再后面的若干行中，
依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）
给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。已知矩阵中整数的范围都在[-127, 127]。
输出
输出最大子矩阵的大小。
样例输入
4
0 -2 -7 0 9 2 -6 2
-4 1 -4  1 -1

8  0 -2
样例输出
15



思路：
输入每一项的值，然后得到最大的一项，同时将每一项累加即输出每一项的同时，将前面输出的所有的项的和加上当前项的值赋值给当前项，然后构建一个循环嵌套，第一个for循环控制子矩阵的第一个列，
第二个for循环控制子矩阵的最后一个列，然后再构建一个for循环控制子矩阵的行，每一行的子段和等于当前行最后一列的值减去当前行第一列前一列的值，然后每行依次累加，然后比较得到最大值


代码：
//最大子矩阵和
#include<bits/stdc++.h>
using namespace std;
int n,a[105][105];
int ans=0,sum=0;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        cin>>a[i][j];//输入
        if(a[i][j]>ans)
            ans=a[i][j];//检测是否存在1*1的最大子矩阵，与后面的子矩阵相比较
        a[i][j]+=a[i][j-1];//每一项累加
    }
    for(int i=1;i<=n;i++)//i控制矩阵范围的第一个列
    for(int j=i;j<=n;j++)//j控制矩阵范围的最后一个列
    {
        sum=0;//储存每一个子矩阵的和
        for(int line=1;line<=n;line++)//line控制矩阵范围的行
        {
            sum+=a[line][j]-a[line][i-1];//相减可得每一行的子段和，然后累加，得到子矩阵的和
            ans=max(ans,sum);//比较子矩阵和的大小
            if(sum<0)//若该子矩阵和小于0，则将sum清零
                sum=0;
        }
    }
    cout<<ans;//输出
    return 0;
}

















