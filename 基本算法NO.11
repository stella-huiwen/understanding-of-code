移动石头
链接：https://ac.nowcoder.com/acm/problem/21740
来源：牛客网

题目描述 
有n堆石头排成一排，标号为0到n-1，第i堆石头有a[i]个石头
每一步你可以从某一堆取一个石头放到相邻的石头堆里
请问需要多少步可以将a数组变成b数组
输入描述:
第一行先输入一个整数n (1 ≤ ≤ 50)
第二行输入n个数ai
第三行输入n个数bi

0 ≤ ai, bi ≤ 106
输出描述:
输出一个整数表示最少的操作步数，如果无法将a数组变成b数组，输出-1
示例1
输入
复制
2
1 2
2 1
输出
复制
1
示例2
输入
复制
2
10 0
0 10
输出
复制
10
示例3
输入
复制
3
0 0 1
1 0 0
输出
复制
2
示例4
输入
复制
9
3 10 0 4 0 0 0 1 0
5 5 0 7 0 0 0 0 1
输出
复制
9
备注:
子任务1：n <= 10
子任务2：n <= 20
子任务3：无限制


思路：
输入a,b数组，循环比较a,b数组的每一项，a比b大，则a下一项加a比b大的部分，同时这部分也为移动次数，当a比b小，则a下一项减a比b小的部分，同时这部分也为移动次数；
如果在比较最后一项后，最后一项的后一项等于零，则说明a数组能变成b数组，输出变化次数，否则，输出-1




代码：
//移动石头
#include<bits/stdc++.h>
using namespace std;
int a[55],b[55];
int main()
{
    int n,ans=0;
    cin>>n;//输入
    for(int i=0;i<n;i++)
        cin>>a[i];
    for(int i=0;i<n;i++)
        cin>>b[i];
    for(int i=0;i<n;i++)//比较a,b数组
    {
        if(a[i]>b[i])//当a数组大于b数组时，将a数组多余的部分加到a数组的下一项，ans记录次数
        {
            a[i+1]+=a[i]-b[i];
            ans+=a[i]-b[i];
        }
        if(a[i]<b[i])//当a数组小于b数组，将a数组下一项减去当前a数组所在向少于b数组的部分
        {
            a[i+1]-=b[i]-a[i];
            ans+=b[i]-a[i];//ans记录次数
        }
    }
    if(a[n]!=0||b[n]!=0)//当数组最后一项的后一项不为零时，说明a数组不能变为b数组
        cout<<"-1";
    else
        cout<<ans;//输出
    return 0;
}
    
