求两个不超过200位的非负整数的和。(高精度整数相加）

输入
有两行，每行是一个不超过200位的非负整数，可能有多余的前导0。
输出
一行，即相加后的结果。结果里不能有多余的前导0，即如果结果是342，那么就不能输出为0342。
样例输入
22222222222222222222
33333333333333333333
样例输出
55555555555555555555

进位模拟：
1439+887
首先我们最低位相加，即9+7，得到16，
那么答案最低位就是6，
再进个1，然后两数的十位相加，3+8=11，然后再加上进位的1，就是11+1=12，所以答案十位就是2，
再进1，4+8+1=13，答案百位是3，
进1，1+0+1=2，答案千位是2。
所以结果就是6232，又因为是倒序储存，则正确答案为2326


代码：
//高精度整数加法
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string a,b;
    int x[1000],y[1000],len;
    memset(x,0,sizeof(x));
    memset(y,0,sizeof(y));
    cin>>a>>b;//输入两个字符串
    x[0]=a.length();//取得字符长度
    y[0]=b.length();
    for(int i=1;i<=x[0];i++)//将两个字符串倒序储存在数组中
        x[i]=a[x[0]-i]-'0';
    for(int i=1;i<=y[0];i++)
        y[i]=b[y[0]-i]-'0';
    len=max(x[0],y[0]);//选取字符长度较大的
    for(int i=1;i<=len;i++)//按位加法，同时进位
    {
        x[i]+=y[i];
        x[i+1]+=x[i]/10;
        x[i]%=10;
    }
    len++;//两数相加，答案长度可能会边长
    while((x[len]==0)&&len>1)//判断答案长度是否变长，若无，则去掉最高位的0
        len--;
    for(int i=len;i>=1;i--)//倒序输出数组
        cout<<x[i];
    return 0;
}
