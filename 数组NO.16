错误探测
总时间限制: 1000ms 内存限制: 65536kB
描述
给定n*n由0和1组成的矩阵，如果矩阵的每一行和每一列的1的数量都是偶数，则认为符合条件。
你的任务就是检测矩阵是否符合条件，或者在仅改变一个矩阵元素的情况下能否符合条件。
"改变矩阵元素"的操作定义为0变成1或者1变成0。

输入
输入n + 1行，第1行为矩阵的大小n(0 < n < 100)，以下n行为矩阵的每一行的元素，元素之间以一个空格分开。
输出
如果矩阵符合条件，则输出OK；
如果矩阵仅改变一个矩阵元素就能符合条件，则输出需要改变的元素所在的行号和列号，以一个空格分开。
如果不符合以上两条，输出Corrupt。
样例输入
样例输入1
4
1 0 1 0
0 0 0 0
1 1 1 1
0 1 0 1

样例输入2
4
1 0 1 0
0 0 1 0
1 1 1 1
0 1 0 1

样例输入3
4
1 0 1 0
0 1 1 0
1 1 1 1
0 1 0 1
样例输出
样例输出1
OK

样例输出2
2 3

样例输出3
Corrupt



思路：
由题可知，分为三种情况，第一种：行和列中1的个数都为偶数；
                      第二种：需改变一个数字；
                      第三种：需改变两个以上的数字
则可以先遍历数组，把每行中1的个数记录，然后用数组储存每行中1的个数为奇数的行，且记录是奇数的行的个数；
然后再遍历数组，记录每列中1的个数，用另一个数组记录每列中1的个数是奇数的列，且记录是奇数的列的个数
最后如果是奇数的行的个数和列的个数都为零，则说明是第一种情况
如果个数都为1，则是第二种情况
否则，为第三种情况


代码：
//错误勘测
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,k=0;
    scanf("%d",&n);
    int a[n+5][n+5],b[n],c[n],t1=0,t2=0;
    for(int i=1;i<=n;i++)
    {
        k=0;
        for(int j=1;j<=n;j++)
        {
            scanf("%d",&a[i][j]);
            if(a[i][j]==1)
                k++;
        }
        if(k%2!=0)
        {
            b[t1]=i;
            t1++;
        }
    }
    for(int j=1;j<=n;j++)
    {
        k=0;
        for(int i=1;i<=n;i++)
        {
            if(a[i][j]==1)
            k++;
        }
        if(k%2!=0)
        {
            c[t2]=j;
            t2++;
        }
    }
    if(t1==0&&t2==0)
    printf("OK");
    else if(t1==1&&t2==1)
    printf("%d %d",b[0],c[0]);
    else 
    printf("Corrupt");
    return 0;
}










