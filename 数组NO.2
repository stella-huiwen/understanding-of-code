描述

一个长度为n（n>0）的序列中存在“有趣的跳跃”当前仅当相邻元素的差的绝对值经过排序后正好是从1到(n-1)。例如，1 4 2 3存在“有趣的跳跃”，因为差的绝对值分别为3,2,1。当然，任何只包含单个元素的序列一定存在“有趣的跳跃”。你需要写一个程序判定给定序列是否存在“有趣的跳跃”。

输入
一行，第一个数是n（0 < n < 3000），为序列长度，接下来有n个整数，依次为序列中各元素，各元素的绝对值均不超过1,000,000,000。

输出
一行，若该序列存在“有趣的跳跃”，输出"Jolly"，否则输出"Not jolly"。

样例输入
4 1 4 2 3

样例输出
Jolly

*************************************************************************************************************************************************************************************
代码：（解法一）
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int a[3005],n,b[3005],j=0;
    int flag=1;
    scanf("%d",&n);
    scanf("%d",&a[0]);//第一个被减数，为了减少循环
    for(int i=1;i<n;i++)
    {
        scanf("%d",&a[i]);
        b[j]=abs(a[i]-a[i-1]);//用数组b储存差值的绝对值
        j++;
    }
    sort(b,b+j);//对数组b从小到大排序 
    for(int i=0;i<j;i++)
    {
         if(b[i]!=i+1)//判断差值是否与i相等
             flag=0;//以flag作为判断依据
    }
    if(flag)
        printf("Jolly");
    else
        printf("Not jolly");
    return 0;
}




代码（解法二）
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,m1,m,a[3005]={},b[3005];
    cin>>n;//输入数量
    cin>>m1;//输入第一个被减数
    for(int i=1;i<n;i++)
    {
        cin>>m;//输入后边的数
        a[abs(m1-m)]++;//给数组第差值个元素加1
        m1=m;//下次运算时将下一个数作为被减数计算差的绝对值
    }
    //看数组的1至n-1位是否均为1
    for(int i=1;i<n;i++)
    {
        if(a[i]!=1)
        {
            cout<<"Not jolly";
            return 0;//直接结束代码
        }
    }
cout<<"Jolly";//因为如果输出not jolly之后会直接结束代码 所以结束之后只有一种情况
return 0;
}
