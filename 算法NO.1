未名湖边的烦恼
问题描述
　　每年冬天，北大未名湖上都是滑冰的好地方。北大体育组准备了许多冰鞋，可是人太多了，每天下午收工后，常常一双冰鞋都不剩。
　　每天早上，租鞋窗口都会排起长龙，假设有还鞋的m个，有需要租鞋的n个。现在的问题是，这些人有多少种排法，可以避免出现体育组没有冰鞋可租的尴尬场面。（两个同样需求的人（比如都是租鞋或都是还鞋）交换位置是同一种排法）
输入格式
　　两个整数，表示m和n
输出格式
　　一个整数，表示队伍的排法的方案数。
样例输入
3 2
样例输出
5
数据规模和约定
　　m,n∈［0,18］
　　问题分析
  
  
  
  
  思路：
  先输入人数，然后构建一个递归函数，边界为当还鞋人数小于借鞋人数时，返回0，当借鞋人数为0时，返回1；
  否则，返回s(还鞋人数-1，借鞋人数)+s(还鞋人数，借鞋人数-1)，因为还鞋的人必须站在借鞋的人前面，所以先排列还鞋的人，最后递归，直到输出
  
  代码：
//未名湖边的烦恼
#include<bits/stdc++.h>
using namespace std;
int s(int a,int b)
{
    if(a<b)//当还鞋人数小于借鞋人数，则排列方案为0
    return 0;
    else if(b==0)//当借鞋人数为0时，则排列方案只有一种
    return 1;
    else
    return s(a-1,b)+s(a,b-1);//还鞋的人必须站在借鞋的人前面，所以还鞋的人先排队，然后借鞋的人后排
}
int main()
{
    int m,n;
    cin>>m>>n;//输入
    cout<<s(m,n);//输出
    return 0;
}
